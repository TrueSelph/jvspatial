"""
Test suite for webhook-specific authentication middleware functionality.

This module tests the path-based API key validation, HMAC verification,
raw body preservation, fallback authentication, and route injection
features of the AuthenticationMiddleware when handling webhook paths.
"""

from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from fastapi import Request
from starlette.responses import JSONResponse

from jvspatial.api.auth.entities import APIKey, User
from jvspatial.api.auth.middleware import (
    AuthenticationMiddleware,
    auth_config,
    verify_hmac,
)


class TestWebhookMiddleware:
    """Test webhook-specific middleware functionality."""

    def setup_method(self):
        """Set up test data and mocks."""
        self.mock_app = MagicMock()
        self.middleware = AuthenticationMiddleware(self.mock_app)

        # Real user object
        self.test_user = User(
            id="user_123",
            username="testuser",
            email="test@example.com",
            password_hash="hash",  # pragma: allowlist secret
            roles=["user"],
            permissions=["process_webhooks"],
            is_active=True,
            rate_limit_per_hour=1000,
        )

        # Mock API key
        self.test_api_key = MagicMock()
        self.test_api_key.key_id = "test_key_123"
        self.test_api_key.name = "Test Webhook Key"
        self.test_api_key.key_hash = "hashed_secret"
        self.test_api_key.user_id = "user_123"
        self.test_api_key.is_active = True
        self.test_api_key.hmac_secret = "test_hmac_secret"  # pragma: allowlist secret
        self.test_api_key.rate_limit_per_hour = 500
        self.test_api_key.verify_secret = MagicMock(return_value=True)
        self.test_api_key.is_valid = MagicMock(return_value=True)
        self.test_api_key.can_access_endpoint = MagicMock(return_value=True)
        self.test_api_key.record_usage = AsyncMock()

    @pytest.mark.asyncio
    async def test_webhook_path_auth_success(self):
        """Test successful path-based authentication for webhook."""
        # Mock request for webhook path
        request = MagicMock(spec=Request)
        request.url.path = (
            "/webhooks/test/key_id:test_secret"  # pragma: allowlist secret
        )
        request.body.return_value = b'{"test": "data"}'
        request.headers.get.side_effect = lambda k, default=None: (
            "application/json" if k == "content-type" else None
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []
        request.state.required_permissions = []
        request.state.required_roles = []

        # Mock API key validation
        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            return_value=self.test_api_key,
        ):
            with patch.object(self.test_api_key, "verify_secret", return_value=True):
                with patch(
                    "jvspatial.api.auth.entities.User.get", return_value=self.test_user
                ):
                    call_next = AsyncMock()
                    call_next.return_value = "response"

                    result = await self.middleware.dispatch(request, call_next)

                    # Should proceed to next middleware
                    assert result == "response"
                    call_next.assert_called_once_with(request)

                    # Verify state was set correctly
                    assert request.state.current_user == self.test_user
                    assert hasattr(request.state, "api_key_obj")
                    assert request.state.api_key_obj == self.test_api_key
                    assert request.state.webhook_route == "test"
                    assert request.state.raw_body == b'{"test": "data"}'
                    assert request.state.content_type == "application/json"

    @pytest.mark.asyncio
    async def test_webhook_path_auth_invalid_key_id(self):
        """Test path-based auth failure with invalid key ID."""
        request = MagicMock(spec=Request)
        request.url.path = "/webhooks/test/invalid_key:test_secret"
        request.body.return_value = b'{"test": "data"}'
        request.headers.get.side_effect = lambda k, default=None: (
            "application/json" if k == "content-type" else None
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []

        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            return_value=None,
        ):
            call_next = AsyncMock()

            result = await self.middleware.dispatch(request, call_next)

            # Should return 401
            assert isinstance(result, JSONResponse)
            assert result.status_code == 401
            assert "Authentication required" in result.body.decode()

    @pytest.mark.asyncio
    async def test_webhook_path_auth_invalid_secret(self):
        """Test path-based auth failure with invalid secret."""
        request = MagicMock(spec=Request)
        request.url.path = "/webhooks/test/test_key_123:wrong_secret"
        request.body.return_value = b'{"test": "data"}'
        request.headers.get.side_effect = lambda k, default=None: (
            "application/json" if k == "content-type" else None
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []

        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            return_value=self.test_api_key,
        ):
            with patch.object(self.test_api_key, "verify_secret", return_value=False):
                call_next = AsyncMock()

                result = await self.middleware.dispatch(request, call_next)

                # Should return 401
                assert isinstance(result, JSONResponse)
                assert result.status_code == 401
                assert "Authentication required" in result.body.decode()

    @pytest.mark.asyncio
    async def test_webhook_path_auth_inactive_key(self):
        """Test path-based auth with inactive API key."""
        inactive_key = MagicMock(spec=APIKey)
        inactive_key.is_active = False
        inactive_key.verify_secret.return_value = True

        request = MagicMock(spec=Request)
        request.url.path = "/webhooks/test/test_key_123:valid_secret"
        request.body.return_value = b'{"test": "data"}'
        request.headers.get.side_effect = lambda k, default=None: (
            "application/json" if k == "content-type" else None
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []

        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            return_value=inactive_key,
        ):
            with patch(
                "jvspatial.api.auth.entities.User.get", return_value=self.test_user
            ):
                call_next = AsyncMock()

                result = await self.middleware.dispatch(request, call_next)

                # Should return 401 for inactive key
                assert isinstance(result, JSONResponse)
                assert result.status_code == 401

    @pytest.mark.asyncio
    async def test_webhook_path_auth_inactive_user(self):
        """Test path-based auth with inactive user."""
        inactive_user = MagicMock(spec=User)
        inactive_user.is_active = False

        request = MagicMock(spec=Request)
        request.url.path = "/webhooks/test/test_key_123:valid_secret"
        request.body.return_value = b'{"test": "data"}'
        request.headers.get.side_effect = lambda k, default=None: (
            "application/json" if k == "content-type" else None
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []

        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            return_value=self.test_api_key,
        ):
            with patch.object(self.test_api_key, "verify_secret", return_value=True):
                with patch(
                    "jvspatial.api.auth.entities.User.get", return_value=inactive_user
                ):
                    call_next = AsyncMock()

                    result = await self.middleware.dispatch(request, call_next)

                    # Should return 401 for inactive user
                    assert isinstance(result, JSONResponse)
                    assert result.status_code == 401

    @pytest.mark.asyncio
    async def test_webhook_hmac_success(self):
        """Test successful HMAC verification."""
        # Mock valid HMAC
        valid_signature = "a1b2c3d4e5f6"  # Mock valid sig  # pragma: allowlist secret
        request = MagicMock(spec=Request)
        request.url.path = "/webhooks/test/test_key_123:valid_secret"
        request.body.return_value = b'{"test": "data"}'
        request.headers.get.side_effect = lambda k, default=None: (
            valid_signature if k == auth_config.hmac_header else "application/json"
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []

        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            return_value=self.test_api_key,
        ):
            with patch.object(self.test_api_key, "verify_secret", return_value=True):
                with patch(
                    "jvspatial.api.auth.entities.User.get", return_value=self.test_user
                ):
                    with patch(
                        "jvspatial.api.auth.middleware.verify_hmac", return_value=True
                    ):
                        call_next = AsyncMock()
                        call_next.return_value = "response"

                        result = await self.middleware.dispatch(request, call_next)

                        # Should proceed successfully
                        assert result == "response"
                        call_next.assert_called_once_with(request)

    @pytest.mark.asyncio
    async def test_webhook_hmac_failure(self):
        """Test HMAC verification failure."""
        invalid_signature = "wrong_signature"
        request = MagicMock(spec=Request)
        request.url.path = "/webhooks/test/test_key_123:valid_secret"
        request.body.return_value = b'{"test": "data"}'
        request.headers.get.side_effect = lambda k, default=None: (
            invalid_signature if k == auth_config.hmac_header else "application/json"
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []

        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            return_value=self.test_api_key,
        ):
            with patch.object(self.test_api_key, "verify_secret", return_value=True):
                with patch(
                    "jvspatial.api.auth.entities.User.get", return_value=self.test_user
                ):
                    with patch(
                        "jvspatial.api.auth.middleware.verify_hmac", return_value=False
                    ):
                        call_next = AsyncMock()

                        result = await self.middleware.dispatch(request, call_next)

                        # Should return 401 for invalid HMAC
                        assert isinstance(result, JSONResponse)
                        assert result.status_code == 401
                        assert "HMAC signature invalid" in result.body.decode()

    @pytest.mark.asyncio
    async def test_webhook_hmac_bypass_no_signature(self):
        """Test HMAC bypass when no signature provided."""
        request = MagicMock(spec=Request)
        request.url.path = "/webhooks/test/test_key_123:valid_secret"
        request.body.return_value = b'{"test": "data"}'
        request.headers.get.side_effect = lambda k, default=None: (
            None if k == auth_config.hmac_header else "application/json"
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []

        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            return_value=self.test_api_key,
        ):
            with patch.object(self.test_api_key, "verify_secret", return_value=True):
                with patch(
                    "jvspatial.api.auth.entities.User.get", return_value=self.test_user
                ):
                    # verify_hmac should not be called since no signature
                    with patch(
                        "jvspatial.api.auth.middleware.verify_hmac"
                    ) as mock_verify:
                        call_next = AsyncMock()
                        call_next.return_value = "response"

                        result = await self.middleware.dispatch(request, call_next)

                        # Should proceed (bypass HMAC)
                        assert result == "response"
                        mock_verify.assert_not_called()

    @pytest.mark.asyncio
    async def test_webhook_hmac_bypass_no_secret(self):
        """Test HMAC bypass when API key has no hmac_secret."""
        key_no_secret = MagicMock(spec=APIKey)
        key_no_secret.key_id = "test_key_123"
        key_no_secret.user_id = "user_123"
        key_no_secret.hmac_secret = None
        key_no_secret.verify_secret.return_value = True
        key_no_secret.is_valid.return_value = True
        key_no_secret.record_usage = AsyncMock()
        key_no_secret.rate_limit_per_hour = 500

        request = MagicMock(spec=Request)
        request.url.path = "/webhooks/test/test_key_123:valid_secret"
        request.body.return_value = b'{"test": "data"}'
        request.headers.get.side_effect = lambda k, default=None: (
            "some_signature"
            if k == auth_config.hmac_header
            else "application/json" if k == "content-type" else None
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []

        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            return_value=key_no_secret,
        ):
            with patch(
                "jvspatial.api.auth.entities.User.get", return_value=self.test_user
            ):
                # verify_hmac should not be called since no hmac_secret
                with patch("jvspatial.api.auth.middleware.verify_hmac") as mock_verify:
                    call_next = AsyncMock()
                    call_next.return_value = "response"

                    result = await self.middleware.dispatch(request, call_next)

                    # Should proceed (bypass HMAC)
                    assert result == "response"
                    mock_verify.assert_not_called()

    @pytest.mark.asyncio
    async def test_webhook_raw_body_preservation(self):
        """Test raw body preservation for non-JSON content types."""
        # Test with text/plain
        request = MagicMock(spec=Request)
        request.url.path = "/webhooks/test/test_key_123:valid_secret"
        raw_payload = b"This is plain text payload"
        request.body.return_value = raw_payload
        request.headers.get.side_effect = lambda k, default=None: (
            "text/plain" if k == "content-type" else None
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []

        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            return_value=self.test_api_key,
        ):
            with patch.object(self.test_api_key, "verify_secret", return_value=True):
                with patch(
                    "jvspatial.api.auth.entities.User.get", return_value=self.test_user
                ):
                    call_next = AsyncMock()
                    call_next.return_value = "response"

                    result = await self.middleware.dispatch(request, call_next)

                    # Should preserve raw body
                    assert request.state.raw_body == raw_payload
                    assert request.state.content_type == "text/plain"
                    assert result == "response"

    @pytest.mark.asyncio
    async def test_webhook_fallback_to_header_auth(self):
        """Test fallback to header authentication when path auth fails."""
        # Invalid path auth, but valid header auth
        request = MagicMock(spec=Request)
        request.url.path = "/webhooks/test/invalid_key:wrong_secret"
        request.body.return_value = b'{"test": "data"}'
        request.headers.get.side_effect = lambda k, default=None: (
            "valid_key:valid_secret"
            if k == auth_config.api_key_header
            else "application/json"
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []

        # Path auth fails (no mock for invalid key)
        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            side_effect=lambda key_id: (
                self.test_api_key if key_id == "valid_key" else None
            ),
        ):
            with patch.object(self.test_api_key, "verify_secret", return_value=True):
                with patch(
                    "jvspatial.api.auth.entities.User.get", return_value=self.test_user
                ):
                    call_next = AsyncMock()
                    call_next.return_value = "response"

                    result = await self.middleware.dispatch(request, call_next)

                    # Should succeed via fallback header auth
                    assert result == "response"
                    assert request.state.current_user == self.test_user
                    # webhook_route should not be set since path auth failed
                    # (with mocks we need to check if it was set rather than hasattr)
                    webhook_route = getattr(request.state, "webhook_route", None)
                    # It might be a Mock or None, but shouldn't be a real route string
                    assert webhook_route != "test"

    @pytest.mark.asyncio
    async def test_webhook_route_injection(self):
        """Test webhook route extraction and injection into request state."""
        request = MagicMock(spec=Request)
        request.url.path = "/webhooks/stripe/test_key_123:valid_secret"
        request.body.return_value = b'{"type": "payment"}'
        request.headers.get.side_effect = lambda k, default=None: (
            "application/json" if k == "content-type" else None
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []

        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            return_value=self.test_api_key,
        ):
            with patch.object(self.test_api_key, "verify_secret", return_value=True):
                with patch(
                    "jvspatial.api.auth.entities.User.get", return_value=self.test_user
                ):
                    call_next = AsyncMock()
                    call_next.return_value = "response"

                    result = await self.middleware.dispatch(request, call_next)

                    # Route should be injected as "stripe"
                    assert request.state.webhook_route == "stripe"
                    assert result == "response"

    @pytest.mark.asyncio
    async def test_non_webhook_path_normal_behavior(self):
        """Test that non-webhook paths use normal authentication flow."""
        request = MagicMock(spec=Request)
        request.url.path = "/api/normal/endpoint"
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []
        request.state.required_permissions = []

        # Mock normal JWT auth success
        with patch.object(
            self.middleware, "_authenticate_jwt", return_value=self.test_user
        ):
            call_next = AsyncMock()
            call_next.return_value = "response"

            result = await self.middleware.dispatch(request, call_next)

            # Should use normal auth flow
            assert result == "response"
            assert request.state.current_user == self.test_user
            # No webhook-specific state should be set
            # (with mocks, check values rather than hasattr)
            raw_body = getattr(request.state, "raw_body", None)
            webhook_route = getattr(request.state, "webhook_route", None)
            # These should be Mock objects or None, not actual values
            assert raw_body != b'{"test": "data"}'
            assert webhook_route != "api"

    @pytest.mark.asyncio
    async def test_webhook_no_body(self):
        """Test webhook handling with no request body."""
        request = MagicMock(spec=Request)
        request.url.path = "/webhooks/test/test_key_123:valid_secret"
        request.body.return_value = b""
        request.headers.get.side_effect = lambda k, default=None: (
            "application/json" if k == "content-type" else None
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []

        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            return_value=self.test_api_key,
        ):
            with patch.object(self.test_api_key, "verify_secret", return_value=True):
                with patch(
                    "jvspatial.api.auth.entities.User.get", return_value=self.test_user
                ):
                    call_next = AsyncMock()
                    call_next.return_value = "response"

                    result = await self.middleware.dispatch(request, call_next)

                    # Should set empty raw_body
                    assert request.state.raw_body == b""
                    assert result == "response"

    @pytest.mark.asyncio
    async def test_webhook_rate_limiting_api_key(self):
        """Test rate limiting using API key limits for webhook."""
        request = MagicMock(spec=Request)
        request.url.path = "/webhooks/test/test_key_123:valid_secret"
        request.body.return_value = b'{"test": "data"}'
        request.headers.get.side_effect = lambda k, default=None: (
            "application/json" if k == "content-type" else None
        )
        request.state = MagicMock()
        request.state.required_permissions = []
        request.state.required_roles = []

        with patch(
            "jvspatial.api.auth.entities.APIKey.find_by_key_id",
            return_value=self.test_api_key,
        ):
            with patch.object(self.test_api_key, "verify_secret", return_value=True):
                with patch(
                    "jvspatial.api.auth.entities.User.get", return_value=self.test_user
                ):
                    # Mock rate limiter to fail
                    with patch(
                        "jvspatial.api.auth.middleware.rate_limiter.is_allowed",
                        return_value=False,
                    ):
                        call_next = AsyncMock()

                        result = await self.middleware.dispatch(request, call_next)

                        # Should return 429 using API key rate limit
                        assert isinstance(result, JSONResponse)
                        assert result.status_code == 429
                        assert "Rate limit exceeded" in result.body.decode()
